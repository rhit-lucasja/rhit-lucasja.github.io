<!DOCTYPE html>
<html>
    <head>
        <title>About Me</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="styles.css">
    </head>
    <body>
        <header>
            <b>Jack Lucas</b>
        </header>
        <div class="topnav">
            <a href="index.html">About Me</a>
            <a href="connections.html">Play Christmas Connections</a>
        </div>
        <h3>Hello all, and welcome to my personal website!</h3>
        <div class="container" style="background-color: #88aa88">
            <div class="small-media-content">
                <img src="media/me.jpg">
            </div>
            <div class="text-content">
                <h2>About Me</h2>
                <p>
                    I am a first-year student at Rose-Hulman Institute of Technology.
                    While at Rose, I study Computer Science, and I hope to extend my studies into
                    the following areas of interest to me:
                </p>
                <menu>
                    <li style="padding-bottom: 8px">
                        <b>Cybersecurity - </b>Security and defense have always been areas of interest to me.
                                           As part of the Rose Computer Security Club, I enjoy completing CTFs,
                                           especially those in the reverse engineering category. I have taken
                                           Practical Security courses and plan to minor in Cybersecurity.
                    </li>
                    <li style="padding-bottom: 8px">
                        <b>Mathematics - </b>Mathematics has been my favorite core subject for years, and I love solving
                                         challenging math problems. I plan to either double major or minor in Mathematics,
                                         focusing specifically on discrete math with applications to computer science.
                    </li>
                    <li>
                        <b>Data Science - </b>I researched neural networks and machine learning over the summer,
                                          and I am interested by this field that combines mathematics with
                                          computer science. I plan to take elective courses focused on Data Science.
                    </li>
                </menu>
                <p>
                    I also find it entertaining, as a personal project, to code this website 100% from scratch!
                    Thus, it is a continuous work in progress which I will update as I gain experience.
                </p>
                <p>
                    Along with this website, below are some of my favorite projects (academic and personal)!
                </p>
            </div>
        </div>
        <div class="container" style="background-color: #779977">
            <div class="text-content">
                <h2>Object-Oriented Game Design Project</h2>
                <p>This project was completed as part of my Object-Oriented Software Development class.</p>
                <p>
                    <b>The Task:</b> Create an arcade-style game based on the 1983 game <i>Jetpac</i>
                    while implementing proper object-oriented design principles, such as inheritance, polymorphism,
                    dispatch, and abstraction. Also required were various aspects to the game, such as collectible items
                    and different types of enemies.
                </p>
                <p>
                    <b>The Result:</b> <i>Rose Bonfir</i>, a Rose-Hulman-themed spinoff developed by
                    myself, Nakul Mital, and Xingzhao An. The game puts you in control of Rosie, the beloved mascot,
                    who must use her jetpack to pick up pallets and fuel for building the annual Rose-Hulman bonfire.
                    Along the way, she must avoid and disable various enemy drones by hacking them with binary code.
                </p>
            </div>
            <div class="medium-media-content">
                <video controls>
                    <source src="media/bonfir_gameplay.mp4" type="video/mp4">
                    Your browser does not support the video tag with the .mp4 type.
                </video>
            </div>
        </div>
        <div class="container" style="background-color: #779977">
            <div class="medium-media-content hide-mobile">
                <video controls>
                    <source src="media/bonfir_creator.mp4" type="video/mp4">
                    Your browser does not support the video tag with the .mp4 type.
                </video>
            </div>
            <div class="text-content">
                <h3>Favorite Feature: Custom Level Editor</h3>
                <p>
                    My favorite additional feature for <i>Rose Bonfir</i> is the level editor, which allows users
                    to place Rosie, the bonfire, and multiple platforms in a custom level layout. The layout is
                    then saved to a file, where it can be loaded and played from the level selection menu.
                </p>
                <p>
                    The hardest part of the level creator was preventing certain illegal level formats. However, I
                    was able to implement certain conditions that were checked before placing elements and/or saving
                    a level to a file. Now, the level creator prevents issues like a bonfire floating in midair,
                    or a level with no spawn point for Rosie!
                </p>
            </div>
            <div class="medium-media-content show-mobile">
                <video controls>
                    <source src="media/bonfir_creator.mp4" type="video/mp4">
                    Your browser does not support the video tag with the .mp4 filetype.
                </video>
            </div>
        </div>
        <div style="background-color: #88aa88; padding: 16px">
            <h2>Neural Networks and Machine Learning</h2>
            <p>
                Over the summer, I studied and learned the basics of machine learning. Although I initially learned
                the basics of neural networks while operating on the MNIST dataset, I decided for this purpose to
                create a new network from scratch to showcase my ability to adapt models for different problems.
            </p>
            <p>
                This network is built purely using Python and numpy. It operates on an XOR dataset that I randomly generated.
                For each random input (x,y), the output is 0 when x and y have the same signs and 1 when x and y have
                different signs. Hence, the problem is XOR-like, since it is not linearly separable. 
            </p>
            <p>
                Using pyplot, I generated various graphs to showcase the typical performance of my network below. In this 
                particular run, I employed a no-improvement-in-twenty epochs method to cause early stoppage. This learning
                cycle went for about 25 epochs, achieving an ultimate accuracy of 92%. I tried to optimize the structure
                and hyperparameters of the network as much as possible, but given the short period it was built in, I am
                pretty satisfied with the overall result. I also integrated certain optimization techniques, such as a
                variable learning rate and L2 regularization, into this newly created network.
            </p>
        </div>
        <div class="container" style="background-color: #88aa88">
            <div class="text-content show-mobile">
                <h3>Cost and Accuracy Analytics Over Time</h3>
                <p>
                    The first graph below plots the cross-entropy cost, calculated on both the training and evaluation
                    datasets, over the training period.
                </p>
                <p>
                    The second graph plots the overall accuracy of the neural network on both the training and evaluation
                    datasets, evaluated after each epoch during the training period.
                </p>
            </div>
            <div class="large-media-content">
                <img src="media/xor_cost.png">
            </div>
            <div class="text-content hide-mobile">
                <h3>Cost and Accuracy Analytics Over Time</h3>
                <p>
                    The graph on the left plots the cross-entropy cost, calculated on both the training and evaluation
                    datasets, over the training period.
                </p>
                <p>
                    The graph on the right plots the overall accuracy of the neural network on both the training and
                    evaluation datasets, evaluated after each epoch during the training period.
                </p>
            </div>
            <div class="large-media-content">
                <img src="media/xor_acc.png">
            </div>
        </div>
        <div class="container" style="background-color: #88aa88">
            <div class="text-content hide-mobile">
                <h3>Output for Validation Data</h3>
                <p>
                    To the right is a scatterplot of the 10,000 points of evaluation data, visualized on a [-1, 1] X [-1, 1]
                    coordinate grid. Each point is colored blue (1) or red (0), based on what the neural network in its
                    final state outputs given each coordinate pair as input. Evidently, the network fairly accurately
                    separates the quadrants. Understandably, it fails most at guessing the values which are lower in
                    magnitude.
                </p>
            </div>
            <div class="text-content show-mobile">
                <h3>Output for Validation Data</h3>
                <p>
                    Below is a scatterplot of the 10,000 points of evaluation data, visualized on a [-1, 1] X [-1, 1]
                    coordinate grid. Each point is colored blue (1) or red(0), based on what the neural network in its
                    final state outputs given each coordinate pair as input. Evidently, the network fairly accurately
                    separates the quadrants. Understandably, it fails most at guessing the values which are lower in
                    magnitude.
                </p>
            </div>
            <div class="large-media-content">
                <img src="media/xor_est.png">
            </div>
        </div>
        <div class="container" style="background-color: #779977">
            <div class="text-content">
                <h2>Operating Systems Multithreading Project</h2>
                <p>This project was completed as part of my Operating Systems class.</p>
                <p>
                    <b>The Task:</b> Implement a custom API that adds threading capability to the xv6 operating system.
                    Using the API, any user program should be able to create multiple threads, execute them in parallel
                    (or as close to parallel as xv6 allows--more on that later), and join threads together upon completion.
                    Threads must share the same physical memory, and any updates to memory by one thread should be accessible
                    by all other threads of the same process.
                </p>
                <p>
                    <b>The Result:</b> <i>rhthr</i>, the palindromic and tongue-twisting Rose-Hulman threading library
                    designed and developed by myself, Tal Belkind, and Oskar Steiger. We tested our threads extensively,
                    ensuring all the required elements functioned properly.
                </p>
                <p>
                    Threads share the same physical memory. Threads can pass pointers between each other, updating and
                    accessing the data at the specified addresses. Any call to sbrk(), which allocates and maps a new
                    page to the calling thread's pagetable, was propagated to all threads of the same process; that is,
                    each thread's pagetable was updated to reflect changes. All of this was coded into system calls that
                    formed the backbone behind our three-function user API:
                </p>
            </div>
            <div class="large-media-content hide-mobile">
                <img src="media/os_tests_run.png">
            </div>
        </div>
        <div class="container" style="background-color: #779977">
            <div class="text-content">
                <menu>
                    <li style="padding-bottom: 8px">
                        <b>rhthr_create(int*, void* (void*), void*);</b> - This function creates a new thread, storing a unique
                                                    thread ID at the address given by the int* argument. The child thread starts
                                                    execution at a provided void* function, which takes a single void* argument,
                                                    also provided as the third argument to rhthr_create(). The thread creation system
                                                    call starts a struct proc for the new thread, creates a copy of the original
                                                    process's pagetable (with the same mappings to shared physical space), and 
                                                    allocates space for the new thread's stack, which is separated from the others.
                    </li>
                    <li style="padding-bottom: 8px">
                        <b>rhthr_join(int*);</b> - This function is called by the parent process to join its child thread with
                                                   a specific thread ID, which is stored at the location given by its int* argument.
                                                   In brief, rhthr_join() erases the struct proc belonging to the joined thread,
                                                   decrementing any file and physical memory reference counts as it does so. Clean up
                                                   time!
                    </li>
                    <li>
                        <b>rhthr_exit();</b> - This function should be called at the end of a thread's line of execution.
                                               Although not implemented in this final project, in an earlier CSSE 332 assignment
                                               I programmed implicit thread exiting so that userspace threads could simply return
                                               from their thread function rather than have to call a thread-specific exit() function.
                                               rhthr_exit() signals the operating system to mark the calling thread as no longer
                                               runnable by the scheduler, and the thread idles until it is joined by its parent process.
                    </li>
                </menu>
            </div>
            <div class="large-media-content show-mobile">
                <img src="media/os_tests_run.png">
            </div>
            <div class="large-media-content">
                <img src="media/os_tests.png">
            </div>
        </div>
        <div class="container" style="background-color: #779977">
            <div class="large-media-content hide-mobile">
                <img src="media/os_unbuffered.png">
            </div>
            <div class="text-content">
                <h3>Favorite Design Approach: Testing</h3>
                <p>
                    My favorite additional feature for the threading project was our unique approach to testing, which stood
                    out among the class. Instead of having threads print to stdout and visually inspecting for unexpected
                    behavior, we created automatic testing capabilities. Using the peculiar fact that file descriptors are
                    assigned linearly in xv6, we could redirect stdout, test our thread creation and execution, and compare
                    the output, printed by various parallel threads to an output.txt file, to the expected output which was
                    provided upon running the test.
                </p>
                <p class="hide-mobile">
                    Another peculiarity of our provided xv6 operating system was that the function, printf(), was not buffered.
                    Instead, it wrote to stdout character-by-character, leading to the muddled output shown to the left. Obviously,
                    to run our tests against expected output, we needed a way to fix this odd behavior in order to reliably predict
                    expected outputs. Huge shoutout to Tal Belkind, then, for his work on buffering printf() in xv6!
                </p>
                <p class="show-mobile">
                    Another peculiarity of our provided xv6 operating system was that the function, printf(), was not buffered.
                    Instead, it wrote to stdout character-by-character, leading to the muddled output shown below. Obviously,
                    to run our tests against expected output, we needed a way to fix this odd behavior in order to reliably predict
                    expected outputs. Huge shoutout to Tal Belkind, then, for his work that effectively buffered printf().
                </p>
            </div>
            <div class="large-media-content show-mobile">
                <img src="media/os_unbuffered.png">
            </div>
        </div>
    </body>
</html>